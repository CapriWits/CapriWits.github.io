[{"content":"关于设计绝对值abs的一些思考 「取绝对值」对于 Integer 毫无疑问直接判断正负\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } 注意到双精度浮点数 Double 官方使用以下实现\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java 遵循 IEEE-754 标准，因此实现上存在 +0.0 \u0026amp; -0.0，两者除了文本表示不同，在计算过程中也不同。如：1 / +- 0.0 得到的结果是 +Infinity \u0026amp; -Infinity\nabs 计算结果仍然是负数，出现错误，原因既是 +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } 尝试解决问题，添加判断条件：if (val \u0026lt; 0 || val == -0.0) 对 -0.0 单独考虑，进行双重判断，这里采用 Double::compare(double, double) 实现\n成功实现\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } 再追求极致的优化。查看 Double::compare 实现。\n对于正数进行额外的两次比较, 对于 -0.0 进行额外的 三次 比较, 对于 +0.0 进行额外的 四次 比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } 而实际上，要想实现只需要 Double::doubleToLongBits 方法，将 Double 转 Long\n1 2 3 4 5 6 7 8 9 10 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 不过 Double::doubleToLongBits 也只有微不足道的性能提升，因为它会对 NaN 进行约束，NaN 会赋值为 0x7ff8000000000000L ，如果确保 abs 入参肯定是 double，则只需要取出 Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } 于是就变成这样实现\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 到 JDK8 就结束了，而 JDK9 开始引入 @HotSpotIntrinsicCandidate 注解，即 HotSpot JVM 内部的 JIT compiler 会移除 JDK 中的实现方法，采用 CPU 指令直接实现，这会比高级语言转汇编转机器语言要快很多，毕竟 CPU 并不会在乎数据类型的问题，只需要重新解释(reinterpreting) 储存在 CPU 寄存器的一组位的问题，以便于与 Java 数据类型一致。\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); 但这么实现，仍然有条件分支，如果 CPU 分支预测(branch predictor) 失误，性能开销就会增大。接下来考虑减少条件分支。\n利用 0.0 与 +/0.0 作差，都会使正负零转化为正零\n1 2 System.out.println(0.0 - (-0.0)); // 0.0 System.out.println(0.0 - (+0.0)); // 0.0 对方法进行改写\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } 注意到对于普通负数而言，0.0 - value 与 -value 的结果相同，所以合并分支\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } 会发现，JDK Math::abs(double,double) 实现相同（逃\n遵循 IEEE-754 的双精度浮点数二进制表达形式，只需要将二进制在高位符号位改成 0 即可实现转正数(abs)，需要掩码 0x7fffffffffffffffL == 63位 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 最终实现 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } 📌此版本不存在分支，在某些条件下的吞吐量增加 10%，单分支实现在 Java 标准库存在多年，在随即到来的 JDK 18 中，改进版本已经提交「From: 2021/9/18」\n然而在许多情况下，这些改进并没有太大意义，因为 JIT 编译器会适当使用汇编指令(if available) 会完全替代 Java code，所以这种改动并 不能 使程序显著性提升很多（逃\n🔗Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"关于设计绝对值 abs() 的一些思考"},{"content":"Iterator remove 时出现 ConcurrentModificationException 前言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each 实际就是隐式使用 iterator 遍历集合，上面的例子会抛出异常，并删除失败。 a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\n然而删除 倒数第二个 元素却不会报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\n分析 首先先观察 ArrayList 的 iterator()，看迭代器怎么构造。 ArrayList 的 父类 AbstractList 中 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr 是里面的内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursor：下一个要访问的元素的索引 lastRet：上一个访问的元素的索引 expectedModCount 是期望的该 List 被修改的次数，初始化为 modCount modCount 是 AbstractList 的一个成员变量。 The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results. This field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration. Use of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; 结构修改是指那些改变列表大小的修改，或者以某种方式扰乱列表，使得正在进行的迭代可能产生不正确的结果。 此字段由迭代器和 listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出 ConcurrentModificationException以响应 next、remove、previous、set 或 add 操作。这提供了 快速失败 的行为。 深入 ArrayList 里观察 next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 抛出的 ConcurrentModificationException 异常是 checkForComodification() 抛出的。 条件是：modCount != expectedModCount 所以在 add remove 的过程中 modCount 会自增自减。如果用集合的 remove则 List 的 modCount减少一，而 Iterator 的 expectedModCount不变，就会抛出异常。\n至于为什么倒数第二个元素删除不会报错，我们要先了解 Iterator 遍历的特点。\nwhile + iterator 的组合是需要先判空 hasNext()，然后再 next()，最后才 remove()，否则会报错，可以自行实验，调换 next 和 remove。\n因为要先 next，将游标 越过 当前的元素，然后再决定要怎么操作当前的（游标前面的）这个元素，即游标是插在 当前元素 和 下一个元素 的中间（可以这么理解）。\n删除倒数第二个元素的时候，cursor 指向 最后一个元素，而此时删掉了倒数第二个元素后，cursor 和 size() 正好相等了，所以 hasNext() 返回 false，遍历结束，成功的删除了倒数第二个元素。\n建议用法 一个原则是，尽量在遍历的过程中不要对原集合进行增删，容易改变原结构，可以用 immutable 的思想，重新封装一个集合。\n要 remove() ，则要在 iterator() 上面来进行 remove()，因为 Iterator 迭代，就把操作权交给了 Iterator，就不要再用原集合进行操作了。\n正确用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\n以上分析是基于 ArrayList，基于链表的 LinkedList 道理大同小异，思想不变，测试的结果也是不变的。\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove 时出现 ConcurrentModificationException"}]
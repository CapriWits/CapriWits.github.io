[{"content":"关于设计绝对值abs的一些思考 「取绝对值」对于 Integer 毫无疑问直接判断正负\nMath::abs(int) 1 2 3 public static int abs(int a) { return (a \u0026lt; 0) ? -a : a; } 注意到双精度浮点数 Double 官方使用以下实现\nMath::abs(double) 1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0D) ? 0.0D - a : a; } Java 遵循 IEEE-754 标准，因此实现上存在 +0.0 \u0026amp; -0.0，两者除了文本表示不同，在计算过程中也不同。如：1 / +- 0.0 得到的结果是 +Infinity \u0026amp; -Infinity\nabs 计算结果仍然是负数，出现错误，原因既是 +0.0 == -0.0\n1 2 3 4 5 6 7 8 9 10 11 public class Solution { public static void main(String[] args) { double x = -0.0; if (1 / abs(x) \u0026lt; 0) { System.out.println(\u0026#34;abs(x) \u0026lt; 0\u0026#34;); } } public static double abs(double a) { return (a \u0026lt; 0) ? -a : a; } } 尝试解决问题，添加判断条件：if (val \u0026lt; 0 || val == -0.0) 对 -0.0 单独考虑，进行双重判断，这里采用 Double::compare(double, double) 实现\n成功实现\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt; 0 || Double.compare(value, -0.0) == 0) { return -value; } return value; } 再追求极致的优化。查看 Double::compare 实现。\n对于正数进行额外的两次比较, 对于 -0.0 进行额外的 三次 比较, 对于 +0.0 进行额外的 四次 比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static int compare(double d1, double d2) { if (d1 \u0026lt; d2) return -1; // Neither val is NaN, thisVal is smaller if (d1 \u0026gt; d2) return 1; // Neither val is NaN, thisVal is larger // Cannot use doubleToRawLongBits because of possibility of NaNs. long thisBits = Double.doubleToLongBits(d1); long anotherBits = Double.doubleToLongBits(d2); return (thisBits == anotherBits ? 0 : // Values are equal (thisBits \u0026lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN) 1)); // (0.0, -0.0) or (NaN, !NaN) } 而实际上，要想实现只需要 Double::doubleToLongBits 方法，将 Double 转 Long\n1 2 3 4 5 6 7 8 9 10 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 不过 Double::doubleToLongBits 也只有微不足道的性能提升，因为它会对 NaN 进行约束，NaN 会赋值为 0x7ff8000000000000L ，如果确保 abs 入参肯定是 double，则只需要取出 Double::doubleToRawLongBits\n1 2 3 4 5 6 public static long doubleToLongBits(double value) { if (!isNaN(value)) { return doubleToRawLongBits(value); } return 0x7ff8000000000000L; } 于是就变成这样实现\n1 2 3 4 5 6 7 8 9 private static final long MINUS_ZERO_LONG_BITS = Double.doubleToRawLongBits(-0.0); public static double abs(double value) { if (value \u0026lt; 0 || Double.doubleToRawLongBits(value) == MINUS_ZERO_LONG_BITS) { return -value; } return value; } 到 JDK8 就结束了，而 JDK9 开始引入 @HotSpotIntrinsicCandidate 注解，即 HotSpot JVM 内部的 JIT compiler 会移除 JDK 中的实现方法，采用 CPU 指令直接实现，这会比高级语言转汇编转机器语言要快很多，毕竟 CPU 并不会在乎数据类型的问题，只需要重新解释(reinterpreting) 储存在 CPU 寄存器的一组位的问题，以便于与 Java 数据类型一致。\n1 2 @HotSpotIntrinsicCandidate public static native long doubleToRawLongBits(double value); 但这么实现，仍然有条件分支，如果 CPU 分支预测(branch predictor) 失误，性能开销就会增大。接下来考虑减少条件分支。\n利用 0.0 与 +/0.0 作差，都会使正负零转化为正零\n1 2 System.out.println(0.0 - (-0.0)); // 0.0 System.out.println(0.0 - (+0.0)); // 0.0 对方法进行改写\n1 2 3 4 5 6 7 8 9 public static double abs(double value) { if (value == 0) { return 0.0 - value; } if (value \u0026lt; 0) { return -value; } return value; } 注意到对于普通负数而言，0.0 - value 与 -value 的结果相同，所以合并分支\n1 2 3 4 5 6 public static double abs(double value) { if (value \u0026lt;= 0) { return 0.0 - value; } return value; } AKA\n1 2 3 public static double abs(double a) { return (a \u0026lt;= 0.0) ? 0.0 - a : a; } 会发现，JDK Math::abs(double,double) 实现相同（逃\n遵循 IEEE-754 的双精度浮点数二进制表达形式，只需要将二进制在高位符号位改成 0 即可实现转正数(abs)，需要掩码 0x7fffffffffffffffL == 63位 1 bit\n1 System.out.println(Long.bitCount(0x7fffffffffffffffL)); // 63 最终实现 1 2 3 4 public static double abs(double value) { return Double.longBitsToDouble( Double.doubleToRawLongBits(value) \u0026amp; 0x7fffffffffffffffL); } 📌此版本不存在分支，在某些条件下的吞吐量增加 10%，单分支实现在 Java 标准库存在多年，在随即到来的 JDK 18 中，改进版本已经提交「From: 2021/9/18」\n然而在许多情况下，这些改进并没有太大意义，因为 JIT 编译器会适当使用汇编指令(if available) 会完全替代 Java code，所以这种改动并 不能 使程序显著性提升很多（逃\n🔗Reference One does not simply calculate the absolute value\nOpenJDK Double::compare\nJavaSE 8 doubleToLongBits\n","date":"2021-09-18T17:34:24+08:00","image":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/some-thoughts-on-designing-absolute-method/","title":"关于设计绝对值 abs() 的一些思考"},{"content":"Java For-loop For-each Iterator 效率分析 System.nanoTime 计时测试 使用 System.nanoTime() 作差计算耗时 LinkedList::get(int index) 时间复杂度为 $O(n)$，loop 中的操作必须保持一致，因此用 ArrayList 做 Iterator 的集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import java.util.*; public class Solution { public static final int MAGNITUDE = 10000; // 数量级 public static long testForloop(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { str = list.get(i); } end = System.nanoTime(); return end - start; } public static long testForeach(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); for (String s : list) { str = s; } end = System.nanoTime(); return end - start; } public static long testIterator(List\u0026lt;String\u0026gt; list) { long start, end; String str = null; start = System.nanoTime(); Iterator\u0026lt;String\u0026gt; iterator = list.iterator(); while (iterator.hasNext()) { str = iterator.next(); } end = System.nanoTime(); return end - start; } public static void main(String[] args) { /* initialize */ List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; MAGNITUDE; i++) { arrayList.add(String.valueOf(i)); } System.out.println(\u0026#34;For loop: \u0026#34; + testForloop(arrayList)); System.out.println(\u0026#34;Foreach: \u0026#34; + testForeach(arrayList)); System.out.println(\u0026#34;Iterator: \u0026#34; + testIterator(arrayList)); } } 数量级：1,000 For loop: 99000\nForeach: 321700\nIterator: 194500\n数量级：10,000 For loop: 933200\nForeach: 942500\nIterator: 585800\n数量级：100,000 For loop: 3730800\nForeach: 6669800\nIterator: 5215100\n在小数量级上，For-loop 效率会高一点，For \u0026lt; Iterator \u0026lt; For-each， 这里得出的结论根据时间消耗得出，无法仔细比较效率高低，数量级小时，For-loop 效率高一点，整体来说，三者速度级别差不多。\nJMH BenchMark 基准测试 使用到 JMH 基准测试验证三种循环，数量级为百万 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import org.openjdk.jmh.annotations.*; import org.openjdk.jmh.infra.Blackhole; import org.openjdk.jmh.results.format.ResultFormatType; import org.openjdk.jmh.runner.Runner; import org.openjdk.jmh.runner.options.Options; import org.openjdk.jmh.runner.options.OptionsBuilder; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.concurrent.TimeUnit; @State(Scope.Thread) @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.NANOSECONDS) @Fork(1) @Warmup(iterations = 3) @Measurement(iterations = 5) public class JavaLoopBenchMarkTest { private static final int SIZE = 1_000_000; private String[] array; private List\u0026lt;String\u0026gt; arrayList; @Setup public void setup() { array = new String[SIZE]; arrayList = new ArrayList\u0026lt;\u0026gt;(SIZE); for (int i = 0; i \u0026lt; SIZE; i++) { array[i] = String.valueOf(i); arrayList.add(array[i]); } } @Benchmark public void testForLoop(Blackhole bh) { for (int i = 0; i \u0026lt; SIZE; i++) { bh.consume(array[i]); } } @Benchmark public void testForEachLoop(Blackhole bh) { for (String s : array) { bh.consume(s); } } @Benchmark public void testIterator(Blackhole bh) { Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { bh.consume(iterator.next()); } } public static void main(String[] args) throws Exception { Options opt = new OptionsBuilder() .include(JavaLoopBenchMarkTest.class.getSimpleName()) .forks(1) .resultFormat(ResultFormatType.JSON) .result(\u0026#34;benchmark-results.json\u0026#34;) // 生成 json 报告，JMH Visual Chart 可视化分析 .build(); new Runner(opt).run(); } } 基准测试结果分析 1 2 3 4 Benchmark Mode Cnt Score Error Units JavaLoopBenchMarkTest.testForEachLoop avgt 5 143919.250 ± 8507.941 ns/op JavaLoopBenchMarkTest.testForLoop avgt 5 139981.040 ± 4770.272 ns/op JavaLoopBenchMarkTest.testIterator avgt 5 142754.313 ± 8949.872 ns/op 严格来讲三者速度几乎不相上下，硬是要说最快，应该是原生 For-loop, For-each 和 Iterator 应该是一样的\n三种循环的使用建议 《Effective Java》 第三版第 58 条中建议，一般采用 Foreach 进行循环，因为它在 简洁性和 预防Bug上优于 For-loop 和 Iterator（确切说是 Iterator 配合 while 使用）\nFor-each 优势于 While-loop 预防Bug 说到预防Bug，这里牵涉到 第57条 中的 将局部变量的作用域最小化。 为什么要“将局部变量的作用域最小化” 书中提到，原因类似于第 15 条的本质，使类和成员的可访问性最小化。\n将局部变量作用域最小化，可以增强代码的可读性和可维护性，并降低出错的可能性。\n循环中提供了特殊的机会来将变量的作用域最小化。\n无论是传统的 for 循环，还是 for-each 形式的 for 循环，都允许声明循环变量，它们的作用域被限定在正好需要的范围之内。\n如果在循环终止之后不再需要循环变量的内容，for-loop 就优先于 while-loop。\n如下是一种遍历集合的首选做法： 1 2 3 4 // Preferred idiom for iterating over a collection or array for (Element e : c) { ... // Do Someting with e } 如果需要访问迭代器，可能要调用它的 remove 方法，首选做法是利用传统的 for 循环替代 for-each 循环： 1 2 3 4 5 // Idiom for iterating when you need the iterator for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // Do someting with e and i } 为什么有些时候不能用 for-each ，鉴于它是基于 Iterator 的 hasNext() + next()，有时候需要在循环过程中对集合进行操作，\n此时就必须使用 Iterator 对象进行操作了，因为使用 Iterator 循环时，集合的操作权就交给 Iterator，\n虽然可以用集合对象进行操作，如 romove() 但这样会破坏 iterator 初始化的结果，导致最终程序运行的结果与预期偏差很大\n至于为什么 for loop 要比 while loop 更好，参考一下代码片段，连续的两个 while loop，以及出现的一个 bug 1 2 3 4 5 6 7 8 9 Iterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { doSometing(i.next()); } ... Iterator\u0026lt;Element\u0026gt; i2 = c.iterator(); while (i.hasNext()) { // This is bug! doSometing(i2.next()); } 在第二个 while loop 中，使用了 迭代器 i 的判断，实际操作的是 i2 迭代器对象, i 迭代器发生泄露，而不会轻易被发现，IDE 也不会报错, 所以要利用好 for loop 声明迭代器，控制它的作用范围\n上面 bug 程序最终的结果是下面的 while loop 不会执行，因为在上面的 while loop 执行结束之后，迭代器 i 就会遍历到尽头，继续判断 i.hasNext() 只会返回 false\nFor-each 优势于 For-loop 以下面一个 两层集合嵌套迭代出现的 bug 来展开讨论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Can you spot the bug? enum Suit {CLUB, DIAMOND, HEART, SPADE} enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection\u0026lt;Suit\u0026gt; suits = Arrays.asList(Suit.values()); static Collection\u0026lt;Rank\u0026gt; ranks = Arrays.asList(Rank.values()); List\u0026lt;Card\u0026gt; deck = new ArrayList\u0026lt;\u0026gt;(); for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next())); bug在于，在迭代器上对外部的集合 suits 调用太多 next 方法，它应该从外部的循环进行调用，以便每种花色都调用一次，但它却是从内部循环调用，因此每次牌调用一次。在用完所有花色之后，循环就会抛出 NoSuchElementException异常。\n如果碰巧外部集合的大小是内部集合大小的几倍（可能因为它们是相同的集合），循环就会正常终止，但是实际完成情况跟预期是有出入的。\n下面是打印一对骰子出现的所有可能情况： 1 2 3 4 5 6 7 // Same bug, different symptom! enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX} Collection\u0026lt;Face\u0026gt; faces = EnumSet.allOf(Face.class); for (Iterator\u0026lt;Face\u0026gt; i = faces.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Face\u0026gt; j = faces.iterator(); i.hasNext(); ) System.out.println(i.next() + \u0026#34; \u0026#34; + j.next()); ONE ONE\nTWO TWO\nTHREE THREE\nFOUR FOUR\nFIVE FIVE\nSIX SIX\n同样的错误，也是重复调用 next。这种程序不会抛出异常，所以往往找 bug 会特别难受\n下面开始修正此 bug 1 2 3 4 5 6 // Fixed, but ugly - so we need for-each for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) { Suit suit = i.next(); for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(suit, j.next())); } 至此引出 for-each ，让这个问题完全消失，并且产生的代码也能很简洁。 1 2 3 4 // Preferred idiom for neat iteration on collections and arrays for (Suit suit : suits) for (Rank rank : ranks) deck.add(new Card(suit, rank)); For-each 无法使用的地方 解构过滤：如果需要遍历集合，并删除指定元素，需要使用显式的迭代器，以便使用它的 remove 方法。使用 Java 8 中添加的 Collection 的 removeIf，常常可以避免显式遍历。 转换：如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设置元素的值。 平行迭代：如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进（就如上述有问题的牌和骰子的示例中无意间所示范的那样） For-each 拓展使用 for-each 不止能遍历集合和数组，还能遍历实现 Iterable 接口的任何对象，只需要实现接口对应的方法即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface Iterable\u0026lt;T\u0026gt; { /** * Returns an iterator over elements of type {@code T}. * * @return an Iterator. */ Iterator\u0026lt;T\u0026gt; iterator(); default void forEach(Consumer\u0026lt;? super T\u0026gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } } 比如写一个自定义的 LinkedList 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import java.util.Iterator; import java.util.NoSuchElementException; public class SimpleList\u0026lt;T\u0026gt; implements Iterable\u0026lt;T\u0026gt; { private Node\u0026lt;T\u0026gt; head; private static class Node\u0026lt;T\u0026gt; { T data; Node\u0026lt;T\u0026gt; next; Node(T data) { this.data = data; this.next = null; } } public void add(T data) { if (head == null) { head = new Node\u0026lt;\u0026gt;(data); } else { Node\u0026lt;T\u0026gt; current = head; while (current.next != null) { current = current.next; } current.next = new Node\u0026lt;\u0026gt;(data); } } @Override public Iterator\u0026lt;T\u0026gt; iterator() { return new Iterator\u0026lt;T\u0026gt;() { private Node\u0026lt;T\u0026gt; current = head; @Override public boolean hasNext() { return current != null; } @Override public T next() { if (!hasNext()) { throw new NoSuchElementException(); } T data = current.data; current = current.next; return data; } }; } public static void main(String[] args) { SimpleList\u0026lt;String\u0026gt; list = new SimpleList\u0026lt;\u0026gt;(); list.add(\u0026#34;Hello\u0026#34;); list.add(\u0026#34;World\u0026#34;); list.add(\u0026#34;!\u0026#34;); for (String s : list) { System.out.println(s); } } } 总结 总而言之，与传统的 for 循环相比，for-each 循环在简洁性、灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。\n因此，当可以选择的时候，for-each 循环应该优先于 for 循环。\n","date":"2021-03-16T10:37:29+08:00","image":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/java-for_loop_for_each_iterator-efficiency-analysis/","title":"Java For-loop For-each Iterator 效率分析"},{"content":"Iterator remove 时出现 ConcurrentModificationException 前言 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;String\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;b\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;b\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } for-each 实际就是隐式使用 iterator 遍历集合，上面的例子会抛出异常，并删除失败。 a\nException in thread \u0026ldquo;main\u0026rdquo; java.util.ConcurrentModificationException\nat java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:937)\nat java.base/java.util.ArrayList$Itr.next(ArrayList.java:891)\nat Solution.main(Solution.java:14)\n然而删除 倒数第二个 元素却不会报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;c\u0026#34;.equals(cur)) { arrayList.remove(cur); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } /*for (String s : arrayList) { if (\u0026#34;c\u0026#34;.equals(s)) { arrayList.remove(s); } else { System.out.println(s + \u0026#34; \u0026#34;); } }*/ System.out.println(arrayList); } } a\nb\n[a, b, d]\n分析 首先先观察 ArrayList 的 iterator()，看迭代器怎么构造。 ArrayList 的 父类 AbstractList 中 1 2 3 public Iterator\u0026lt;E\u0026gt; iterator() { return new Itr(); } Itr 是里面的内部类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 private class Itr implements Iterator\u0026lt;E\u0026gt; { /** * Index of element to be returned by subsequent call to next. */ int cursor = 0; /** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * List should have. If this expectation is violated, the iterator * has detected concurrent modification. */ int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet \u0026lt; 0) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet \u0026lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } cursor：下一个要访问的元素的索引 lastRet：上一个访问的元素的索引 expectedModCount 是期望的该 List 被修改的次数，初始化为 modCount modCount 是 AbstractList 的一个成员变量。 The number of times this list has been structurally modified. Structural modifications are those that change the size of the list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.\nThis field is used by the iterator and list iterator implementation returned by the iterator and listIterator methods. If the value of this field changes unexpectedly, the iterator (or list iterator) will throw a ConcurrentModificationException in response to the next, remove, previous, set or add operations. This provides fail-fast behavior, rather than non-deterministic behavior in the face of concurrent modification during iteration.\nUse of this field by subclasses is optional. If a subclass wishes to provide fail-fast iterators (and list iterators), then it merely has to increment this field in its add(int, E) and remove(int) methods (and any other methods that it overrides that result in structural modifications to the list). A single call to add(int, E) or remove(int) must add no more than one to this field, or the iterators (and list iterators) will throw bogus ConcurrentModificationExceptions. If an implementation does not wish to provide fail-fast iterators, this field may be ignored.\n1 protected transient int modCount = 0; 结构修改是指那些改变列表大小的修改，或者以某种方式扰乱列表，使得正在进行的迭代可能产生不正确的结果。 此字段由迭代器和 listIterator方法返回的迭代器和列表迭代器实现使用。如果此字段的值意外更改，迭代器（或列表迭代器）将抛出 ConcurrentModificationException以响应 next、remove、previous、set 或 add 操作。这提供了 快速失败 的行为。 深入 ArrayList 里观察 next() 1 2 3 4 5 6 7 8 9 10 11 public E next() { checkForComodification(); int i = cursor; if (i \u0026gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i \u0026gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } 1 2 3 4 final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 抛出的 ConcurrentModificationException 异常是 checkForComodification() 抛出的。 条件是：modCount != expectedModCount 所以在 add remove 的过程中 modCount 会自增自减。如果用集合的 remove则 List 的 modCount减少一，而 Iterator 的 expectedModCount不变，就会抛出异常。\n至于为什么倒数第二个元素删除不会报错，我们要先了解 Iterator 遍历的特点。\nwhile + iterator 的组合是需要先判空 hasNext()，然后再 next()，最后才 remove()，否则会报错，可以自行实验，调换 next 和 remove。\n因为要先 next，将游标 越过 当前的元素，然后再决定要怎么操作当前的（游标前面的）这个元素，即游标是插在 当前元素 和 下一个元素 的中间（可以这么理解）。\n删除倒数第二个元素的时候，cursor 指向 最后一个元素，而此时删掉了倒数第二个元素后，cursor 和 size() 正好相等了，所以 hasNext() 返回 false，遍历结束，成功的删除了倒数第二个元素。\n建议用法 一个原则是，尽量在遍历的过程中不要对原集合进行增删，容易改变原结构，可以用 immutable 的思想，重新封装一个集合。\n要 remove() ，则要在 iterator() 上面来进行 remove()，因为 Iterator 迭代，就把操作权交给了 Iterator，就不要再用原集合进行操作了。\n正确用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.util.*; public class Solution { public static void main(String[] args) { List\u0026lt;String\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(\u0026#34;a\u0026#34;); arrayList.add(\u0026#34;b\u0026#34;); arrayList.add(\u0026#34;c\u0026#34;); arrayList.add(\u0026#34;d\u0026#34;); Iterator\u0026lt;String\u0026gt; iterator = arrayList.iterator(); while (iterator.hasNext()) { String cur = iterator.next(); if (\u0026#34;a\u0026#34;.equals(cur)) { iterator.remove(); } else { System.out.println(cur + \u0026#34; \u0026#34;); } } System.out.println(arrayList); } } b\nc\nd\n[b, c, d]\n以上分析是基于 ArrayList，基于链表的 LinkedList 道理大同小异，思想不变，测试的结果也是不变的。\n","date":"2021-03-15T20:10:31+08:00","image":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/java-programming-cover_hu4193375dbb5d85283668ea46b44f9b7a_34987_120x120_fill_box_smart1_3.png","permalink":"https://capriwits.com/post/iterator-concurrentmodificationexception-problem-when-remove/","title":"Iterator remove 时出现 ConcurrentModificationException"}]